// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exposed_types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DataTypes {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() characterType,
    required TResult Function() gamemodeType,
    required TResult Function() programType,
    required TResult Function() teamType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? characterType,
    TResult? Function()? gamemodeType,
    TResult? Function()? programType,
    TResult? Function()? teamType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? characterType,
    TResult Function()? gamemodeType,
    TResult Function()? programType,
    TResult Function()? teamType,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharacterType value) characterType,
    required TResult Function(GamemodeType value) gamemodeType,
    required TResult Function(ProgramType value) programType,
    required TResult Function(TeamType value) teamType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharacterType value)? characterType,
    TResult? Function(GamemodeType value)? gamemodeType,
    TResult? Function(ProgramType value)? programType,
    TResult? Function(TeamType value)? teamType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharacterType value)? characterType,
    TResult Function(GamemodeType value)? gamemodeType,
    TResult Function(ProgramType value)? programType,
    TResult Function(TeamType value)? teamType,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataTypesCopyWith<$Res> {
  factory $DataTypesCopyWith(DataTypes value, $Res Function(DataTypes) then) =
      _$DataTypesCopyWithImpl<$Res, DataTypes>;
}

/// @nodoc
class _$DataTypesCopyWithImpl<$Res, $Val extends DataTypes>
    implements $DataTypesCopyWith<$Res> {
  _$DataTypesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CharacterTypeCopyWith<$Res> {
  factory _$$CharacterTypeCopyWith(
          _$CharacterType value, $Res Function(_$CharacterType) then) =
      __$$CharacterTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CharacterTypeCopyWithImpl<$Res>
    extends _$DataTypesCopyWithImpl<$Res, _$CharacterType>
    implements _$$CharacterTypeCopyWith<$Res> {
  __$$CharacterTypeCopyWithImpl(
      _$CharacterType _value, $Res Function(_$CharacterType) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CharacterType implements CharacterType {
  const _$CharacterType();

  @override
  String toString() {
    return 'DataTypes.characterType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CharacterType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() characterType,
    required TResult Function() gamemodeType,
    required TResult Function() programType,
    required TResult Function() teamType,
  }) {
    return characterType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? characterType,
    TResult? Function()? gamemodeType,
    TResult? Function()? programType,
    TResult? Function()? teamType,
  }) {
    return characterType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? characterType,
    TResult Function()? gamemodeType,
    TResult Function()? programType,
    TResult Function()? teamType,
    required TResult orElse(),
  }) {
    if (characterType != null) {
      return characterType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharacterType value) characterType,
    required TResult Function(GamemodeType value) gamemodeType,
    required TResult Function(ProgramType value) programType,
    required TResult Function(TeamType value) teamType,
  }) {
    return characterType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharacterType value)? characterType,
    TResult? Function(GamemodeType value)? gamemodeType,
    TResult? Function(ProgramType value)? programType,
    TResult? Function(TeamType value)? teamType,
  }) {
    return characterType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharacterType value)? characterType,
    TResult Function(GamemodeType value)? gamemodeType,
    TResult Function(ProgramType value)? programType,
    TResult Function(TeamType value)? teamType,
    required TResult orElse(),
  }) {
    if (characterType != null) {
      return characterType(this);
    }
    return orElse();
  }
}

abstract class CharacterType implements DataTypes {
  const factory CharacterType() = _$CharacterType;
}

/// @nodoc
abstract class _$$GamemodeTypeCopyWith<$Res> {
  factory _$$GamemodeTypeCopyWith(
          _$GamemodeType value, $Res Function(_$GamemodeType) then) =
      __$$GamemodeTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GamemodeTypeCopyWithImpl<$Res>
    extends _$DataTypesCopyWithImpl<$Res, _$GamemodeType>
    implements _$$GamemodeTypeCopyWith<$Res> {
  __$$GamemodeTypeCopyWithImpl(
      _$GamemodeType _value, $Res Function(_$GamemodeType) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GamemodeType implements GamemodeType {
  const _$GamemodeType();

  @override
  String toString() {
    return 'DataTypes.gamemodeType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GamemodeType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() characterType,
    required TResult Function() gamemodeType,
    required TResult Function() programType,
    required TResult Function() teamType,
  }) {
    return gamemodeType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? characterType,
    TResult? Function()? gamemodeType,
    TResult? Function()? programType,
    TResult? Function()? teamType,
  }) {
    return gamemodeType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? characterType,
    TResult Function()? gamemodeType,
    TResult Function()? programType,
    TResult Function()? teamType,
    required TResult orElse(),
  }) {
    if (gamemodeType != null) {
      return gamemodeType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharacterType value) characterType,
    required TResult Function(GamemodeType value) gamemodeType,
    required TResult Function(ProgramType value) programType,
    required TResult Function(TeamType value) teamType,
  }) {
    return gamemodeType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharacterType value)? characterType,
    TResult? Function(GamemodeType value)? gamemodeType,
    TResult? Function(ProgramType value)? programType,
    TResult? Function(TeamType value)? teamType,
  }) {
    return gamemodeType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharacterType value)? characterType,
    TResult Function(GamemodeType value)? gamemodeType,
    TResult Function(ProgramType value)? programType,
    TResult Function(TeamType value)? teamType,
    required TResult orElse(),
  }) {
    if (gamemodeType != null) {
      return gamemodeType(this);
    }
    return orElse();
  }
}

abstract class GamemodeType implements DataTypes {
  const factory GamemodeType() = _$GamemodeType;
}

/// @nodoc
abstract class _$$ProgramTypeCopyWith<$Res> {
  factory _$$ProgramTypeCopyWith(
          _$ProgramType value, $Res Function(_$ProgramType) then) =
      __$$ProgramTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramTypeCopyWithImpl<$Res>
    extends _$DataTypesCopyWithImpl<$Res, _$ProgramType>
    implements _$$ProgramTypeCopyWith<$Res> {
  __$$ProgramTypeCopyWithImpl(
      _$ProgramType _value, $Res Function(_$ProgramType) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramType implements ProgramType {
  const _$ProgramType();

  @override
  String toString() {
    return 'DataTypes.programType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProgramType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() characterType,
    required TResult Function() gamemodeType,
    required TResult Function() programType,
    required TResult Function() teamType,
  }) {
    return programType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? characterType,
    TResult? Function()? gamemodeType,
    TResult? Function()? programType,
    TResult? Function()? teamType,
  }) {
    return programType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? characterType,
    TResult Function()? gamemodeType,
    TResult Function()? programType,
    TResult Function()? teamType,
    required TResult orElse(),
  }) {
    if (programType != null) {
      return programType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharacterType value) characterType,
    required TResult Function(GamemodeType value) gamemodeType,
    required TResult Function(ProgramType value) programType,
    required TResult Function(TeamType value) teamType,
  }) {
    return programType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharacterType value)? characterType,
    TResult? Function(GamemodeType value)? gamemodeType,
    TResult? Function(ProgramType value)? programType,
    TResult? Function(TeamType value)? teamType,
  }) {
    return programType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharacterType value)? characterType,
    TResult Function(GamemodeType value)? gamemodeType,
    TResult Function(ProgramType value)? programType,
    TResult Function(TeamType value)? teamType,
    required TResult orElse(),
  }) {
    if (programType != null) {
      return programType(this);
    }
    return orElse();
  }
}

abstract class ProgramType implements DataTypes {
  const factory ProgramType() = _$ProgramType;
}

/// @nodoc
abstract class _$$TeamTypeCopyWith<$Res> {
  factory _$$TeamTypeCopyWith(
          _$TeamType value, $Res Function(_$TeamType) then) =
      __$$TeamTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TeamTypeCopyWithImpl<$Res>
    extends _$DataTypesCopyWithImpl<$Res, _$TeamType>
    implements _$$TeamTypeCopyWith<$Res> {
  __$$TeamTypeCopyWithImpl(_$TeamType _value, $Res Function(_$TeamType) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TeamType implements TeamType {
  const _$TeamType();

  @override
  String toString() {
    return 'DataTypes.teamType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TeamType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() characterType,
    required TResult Function() gamemodeType,
    required TResult Function() programType,
    required TResult Function() teamType,
  }) {
    return teamType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? characterType,
    TResult? Function()? gamemodeType,
    TResult? Function()? programType,
    TResult? Function()? teamType,
  }) {
    return teamType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? characterType,
    TResult Function()? gamemodeType,
    TResult Function()? programType,
    TResult Function()? teamType,
    required TResult orElse(),
  }) {
    if (teamType != null) {
      return teamType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharacterType value) characterType,
    required TResult Function(GamemodeType value) gamemodeType,
    required TResult Function(ProgramType value) programType,
    required TResult Function(TeamType value) teamType,
  }) {
    return teamType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharacterType value)? characterType,
    TResult? Function(GamemodeType value)? gamemodeType,
    TResult? Function(ProgramType value)? programType,
    TResult? Function(TeamType value)? teamType,
  }) {
    return teamType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharacterType value)? characterType,
    TResult Function(GamemodeType value)? gamemodeType,
    TResult Function(ProgramType value)? programType,
    TResult Function(TeamType value)? teamType,
    required TResult orElse(),
  }) {
    if (teamType != null) {
      return teamType(this);
    }
    return orElse();
  }
}

abstract class TeamType implements DataTypes {
  const factory TeamType() = _$TeamType;
}
